{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fmodern JetBrains Mono;}}
{\colortbl ;\red0\green0\blue255;\red204\green120\blue50;\red169\green183\blue198;\red128\green128\blue128;\red104\green151\blue187;\red152\green118\blue170;\red255\green198\blue109;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\b\f0\fs22\lang9 Java Basics:\b0\par
\par
.java (language)   --compile----> .class (byte code) .... .JVM (Run TIme)\par
\b Note: \b0 .java is laguage where write the code which will be compile to .class file and it will be executed by JVM. Even now scala langauage also generated .class file after compilation them JVM will treat that equally so JVM is simplly a run time env which is not tightly coupled with only java.\par
\b Different b/w JDK, JRE, JVM :\par
Java Development Kit (JDK)\par
\b0 1. Java SDK.\par
2. Contains compilers and other tools to build java applications.\par
3. Not necessary to run java programs.\par
4. Comes with runtime.\par
\b Java Runtime Enviornment\par
\b0 1. Required to run java applications.\par
2. Runs byte code on the machine it is on\par
3. Language agnostic for example it supports java, scala, groovy class files\par
4. Contains standalone VM\par
\b Java virtual Machine\par
\b0 1. Runs on a computer  any programs that compiled to byte code\par
2. It acts as abstract virtual computer\par
3. It has byte code loader, verifier, and intrerpreter\par
4. Can convert byte into machine specific code\par
\b What is Byte Code ?\par
\b0 Instruction set meant for execution by JVM. Optimized for JVM.\par
\b What is JIT Compiler?\par
\b0 This compiler converts byte code to machine code directly to execution will be optimized and fast.\par
The JIT compilation is an optimization that the runtime performs when it can possibly produce faster execution, based on the code.\par
\b Three ways to run java byte code.\b0\par
1. Intrepret the inmtermidiate byte code directly.\par
2. Just before execution, compile to native code (JIT)\par
3. Covert intermidiate code fully to native code  before excution. Available with AOT (Ahead of time) from java 9\par
\b Java five goal :\par
\b0 1. It must be simple, object oriented, and familiar.\par
2. It must be robust and secure.\par
3. It must be architeure-neutral and portable.\par
4. It must execute with high performance.\par
5.It must intrepreted, threaded, dynamic.\par
OpenJDK for free.\par
{{\field{\*\fldinst{HYPERLINK https://adoptopenjdk.net/ }}{\fldrslt{https://adoptopenjdk.net/\ul0\cf0}}}}\f0\fs22\par
\b Variables declaration and assignment:\par
\b0 var salary = 100000 \par
var - declaration\par
salary - variable\par
1000 - value \par
var is new type which dynmaic. type will be decieded based on assignment.\par
The var keyword was introduced in Java 10. Type inference is used in var keyword in which it detects automatically the datatype of a variable based on the surrounding context. \par
1. We can declare any datatype with the var keyword.\par
2. var can be used in a local variable declaration.\par
3. var cannot be used in an instance and global variable declaration.\par
4. var cannot be used with the generic type.\par
5. var cannot be used without explicit initialization.\par
      // declaration without \par
        // initialization \par
        var variable; \par
     \par
          // This is also not valid \par
        var variable = null; \par
6. var cannot be used with Lambda Expression.\par
// var cannot be used since they \par
          // require explicit target type \par
        var obj = (a, b) -> (a + b); \par
  \par
          // calling add method \par
        System.out.println(obj.add(2, 3)); \par
7. var cannot be used for method parameters and return type.\par
\par
\b Primitives types in java\b0\par
Data Type\tab Size\tab\tab Description\par
byte\tab\tab 1 byte\tab\tab Stores whole numbers from -128 to 127\par
short\tab\tab 2 bytes\tab\tab Stores whole numbers from -32,768 to 32,767\par
int\tab\tab 4 bytes\tab\tab Stores whole numbers from -2,147,483,648 to 2,147,483,647\par
long\tab\tab 8 bytes\tab\tab Stores whole numbers from -9,223,372,036,854,775,808 to \tab\tab\tab\tab                  9,223,372,036,854,775,807\par
float\tab\tab 4 bytes\tab\tab Stores fractional numbers. Sufficient for storing 6 to 7 decimal \tab\tab\tab\tab digits\par
double\tab\tab 8 bytes\tab\tab Stores fractional numbers. Sufficient for storing 15 decimal \tab\tab\tab\tab\tab digits\par
boolean\tab 1 bit\tab\tab Stores true or false values\par
char\tab\tab 2 bytes\tab\tab Stores a single character/letter or ASCII values\par
\par
\b Literals:\par
\b0 A way to specify value inline.\par
int a = 25\par
int salary = 25_000 // this is similar to 25,000 \par
// _ this is called seperator\par
double val = 5.012E15\par
double price = 25D\par
\b What is static typing ?\par
\b0 In java, we need to deciede type at the time of writing code since java is strongly typed language. For example, you can't assign Integer to String ..etc.\par
Type conversion:\par
this happens with compatiable types for example\par
int b = 10\par
double a = b  // type conversion, since both are compatiable and double can hold int value.\par
\b Type casting: \par
\b0 Imcompatiable conversion but programmer knows the value and it can fit in the destination.\par
double a = 10\par
int b = a  // this doesn't works\par
int b = (int) a // this works\par
\b Precision loss :\par
\b0 int a = 3/2   // 1\par
double b = 3/2  // 1 it looks like it will be 1.5 but java analyze right side first so it has droped .5                                   \par
                               // before assigning to left hand side.\par
double c = 3.0/2\par
\b Arrays:\b0\par
Array index start from 0 in java.\par
Multidimentional array\par
int arr [] [] = new int [3] [5]\par
int arr1 [] [] = new int [4] [] // this is possible but both can't be empty\par
Jagged array\par
int arr1[0] = new int[4]\par
int arr1[1] = new int[5]\par
int arr1[2] = new int[7]\par
Array initializer\par
int matrics[][] = \{\par

\pard\li720\sa200\sl276\slmult1\{10, 20, 30\},\par
\{40, 50, 60\},\par
\{70, 80, 90\}\par

\pard\sa200\sl276\slmult1\}\par
\b Operators:\par
\b0 ternary operators\par
boolean bagContents = isRaining ? umbrella : hat\par
\b Control flow:\par
Switch:\par
\b0 We need to add break between switch statement else operations will go on untill it find the break or default. For default value, we don't need to add break.\par
Allowed switch types:\par
byte, short, int, char, string, enum\par
Switch expression:\par
TODO\par
\b For loop:\b0\par

\pard\box\brdrdash\brdrw0 \sa200\sl276\slmult1\cf2\f1\fs20 int \cf3 i\cf2 , \cf3 j\cf2 ;\line\cf4 // comma seperated for loop \line\cf2 for\cf3 (i=\cf5 0\cf2 , \cf3 j=\cf5 10\cf2 ; \cf3 i<\cf5 10\cf2 ; \cf3 i++\cf2 , \cf3 j--) \{\line     System.\cf6\i out\cf3\i0 .println(i+j)\cf2 ;\line\cf3\}\par
\cf0\f0\fs22 Classic for loop for for-each\par
classic is mostly good when we need index based operation.\par
for-each mostly used for collection or simply getting the values.\par
\b Class: \cf3\b0\f1\fs20\par
\cf0\f0\fs22 It has state and behavior.\par
Class is template for object and object is instance of a class.\par
class className \{\par
\tab member variable - state\par
\tab methods - behavior\par
\}\par

\pard\sa200\sl276\slmult1 what is variable shadowing ?\par
variable shadowing is concept where instance variable and method param is same name then it will be shadowed. For example\par

\pard\box\brdrdash\brdrw0 \sa200\sl276\slmult1\cf2\f1\fs20 int \cf6 seat\cf2 ;\line int \cf6 color\cf2 ;\line\cf3 String \cf6 name\cf2 ;\line\line public \cf7 ThisDemo\cf3 (\cf2 int \cf3 seat) \{\line     \cf2 this\cf3 .\cf6 seat \cf3 = seat\cf2 ;\line\cf3\}\line\line\cf2 boolean \cf7 isSeat \cf3 (\cf2 int \cf3 seat) \{\line     \cf2 return \cf6 seat \cf3 >= seat\cf2 ;\f0\lang1033  // this is variable shadowing, we can solve this with this keyword.\f1\lang9\line\cf3\}\cf0\f0\fs22\par

\pard\sa200\sl276\slmult1 what is this reference ?\par
Refers to the instance the method will run on.\par
What is copy constructor ?\par
A copy constructor is a constructor which takes  class instance as argument and takes instance variables as well.\par
\b Call by value or call by reference :\par
\b0 Its call by value all the time in java. - Need to read more on this before interview.\par
\b Recommended practice of access specifier:\par
\b0 1. All state are private\par
2. Methods can be mixed - depends on whether the method is internal only or meant be called outside.\par
3. Use getter and setter to access internal state\par
4. Package-private rarely used\par
5. protected based on inheritance access needs\par
\b\par
Object class: \par
\b0 Object class is super class in java.\par
Every class extends from the object class.\par
\par
\b Exception handling:\b0\par
Exception handling will happens at runtime. Compile time exception will shown directly at compile time.\par
Hierarchy:\par
Throwable\par
\tab 1. Exception\par
\tab\tab a. RuntimeException (Unchecked Excption) - Null Pointer, Array Index out of Bount Exception, IlligalArgument Exception, Airthmetic Exception, NumberFormat Exception\par
\tab\tab b. CompileTime Exception (Checked Exception) -  IO, FileNotFound, SqlException, Parse Exception, Socket Exception.\par
\tab 2. Error\par
Note: If any code extends Exception then that need to under try catch. for Runtime and Error, we don't need try and catch.\par
\par
\par
\par
\par
\par
}
 