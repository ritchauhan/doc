{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fmodern JetBrains Mono;}}
{\colortbl ;\red169\green183\blue198;\red204\green120\blue50;\red152\green118\blue170;\red104\green151\blue187;\red106\green135\blue89;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\b\f0\fs22\lang9 Collections:\par
Array :\par
\b0 Problem of array :\par
1. Limited data structure.\par
2. Only index based access.\par
3. Doesn't have many method on it.\par
4. Static size declaration.\par
\b Collection needs:\par
1. Position based access\b0\par
a. Storage and retrieval by index.\par
b. Needs sorting methods.\par
c. Ordered vs unordered.\par
\b 2. Uniqueness\b0\par
a. Are duplicates allowed.\par
b. Affects adding behavior.\par
c. No need of position based access.\par
\b 3. Retrieval Mechanism\b0\par
a. index based retrieval.\par
b. key based retrievel.\par
c. 'Presence-Only retrieval'.\par
\b 4. Others\b0\par
a. Mutability.\par
b. Concurrency requirnment.\par
\b Collection Types: (Defines the contract of collection).\b0\par
List.\par
Set.\par
Map.\par
Queue.\par
List:\par
\tab a. ArrayList\par
\tab b. LinkedList\par
Set:\par
\tab a. HashSet\par
\tab b. LinkedHashSet\par
\tab c. TreeSet\par
Map:\par
\tab a. HashMap\par
\tab b. TreeMap\par
Queue:\par
\tab a. PriorityQueue\par
\b\par
Big O notation:\par
\b0 1. Linear time  O(n)\par
\tab a. bigger the collection more the time.\par
\tab b. worst case scenario estimation.\par
\tab c. rough time.\par
2. Constant time O(1)\par
\tab a. time is independent of size of the collection.\par
\tab b. its constant but dependent on time.\par
3. Logarithmics time O(Log N)\par
\tab a. time is dependent on collection but linear but logarithimcs.\par
\tab b. this is in between O(1) and O(n)\par
4. Quadratic time O(n^2)\par
\tab a. time is dependent on size of collection but quaratic time.\par
\tab b. for example, finding a duplicate element in a collection. we need to compare element with all other element.\par
\b Iterator:\b0\par
Syntax:\par

\pard\box\brdrdash\brdrw0 \sa200\sl276\slmult1\cf1\f1\fs20 Iterator<Integer> iterator = arrList.iterator()\cf2 ;\line while \cf1 (iterator.hasNext()) \{\line     System.\cf3\i out\cf1\i0 .println(iterator.next())\cf2 ;\line\cf1\}\par
\cf0\f0\fs22 Note:\par
\tab 1. Iterator doesn't allow for concurrent modification on collection which is iterated.\par
\tab If collection changes in between it throw concurrent modification exception.\par
\tab 2. Each iterator holds its own state.\par
\tab 3. With iterator we don't to bother about get and all those get methods it will interally takes care with given collection.\par
\b Equallity:\b0\par
If two objects hashcodes are equal and they return true for equals method then both the objects are equals.\par
If two objects hashcodes are equal but they don't return true for equals comparision then they are not equal.\par
\b What does it means for two object comparision:\par
ObjA > ObjB\par
\b0 1. There's object state in ObjA and ObjB.\par
2. There are clear definition for comparision of those two values.\par
3. Indivisual values or combination of values comparision.\par
\b Three possible return values.\b0\par
1. Argument object is greater than this object.\par
2. Argument object is lesser than this object.\par
3. They both are same.\par
public interface Comparable<T> \{\par
\tab public int compareTo(T o);\par
\}\par
1. Negative value if argument object is greater than this object.\par
2. Positive value if argument object is lesser than this object.\par
3. Zero if both are same.\par
\b Note :  Collection is interface and Collections is utility class.\par
Collection Interface:\par
\b0 Root interface in collection hierarchy.\b\par
\b0 Its super class for most of the collection like list, set, queue, except map.\par
It has most of the generic methods like add ..etc.\par
Methods Type:\par
Add: add, addAll\par
Remove: remove, removeAll, clear, retainAll\par
Inspect: isEmpty, size\par
Process: iterator, stream, toArray\par
These are the generic methods so most of collection which part of Collection interface has it.\par
\b List:\par
\b0 1. its add in insertion order.\par
2. Its allows duplicate.\par
3. set(index, element) is user for replace and add(index, element)\par

\pard\box\brdrdash\brdrw0 \li720\sa200\sl276\slmult1 example:\par
\cf1\f1\fs20 list.add(\cf4 0\cf2 , \cf5 "Element 0"\cf1 )\cf2 ;\f0\lang1033  // this will insert a new element and shift the list.\f1\lang9\line\cf1 list.set(\cf4 0\cf2 , \cf5 "Element 0 replaced"\cf1 )\cf2 ;\f0\lang1033  // this will replace the element on given index.\par

\pard\box\brdrdash\brdrw0 \sa200\sl276\slmult1\cf0\b\fs22\lang9 ArrayList:\par
\tab Performance:\par
\tab\b0 get - O(1)\par
\tab set - O(1)\par
\tab contains - O(n)\par
\tab remove(0) - O(n)\par
\tab add(0) - O(n)\par
\tab add - \par
\tab\tab best case - O(1)\par
\tab\tab worst case - O(n)\par
\tab\tab most case - O(1)\par
\b LinkedList:\par
\tab Performance:\par
\tab\b0 get - O(n)\par
\tab set - O(n)\par
\tab contains - O(n)\par
\tab remove(0) - O(1)\par
\tab remove(index) - O(n) - mostly because of get other wise O(1)\par
\tab add(0) - O(1)\par
\tab add(index) - O(n) - O(n) - mostly because of get other wise O(1)\par
When to use List :\par
1. Position important.\par
2. Duplicates doesn't matter.\par
3. Interation use cases - do x for all the elements.\par
ArrayList Vs LinkedList:\par
1. Position based access- ArrayList (Index based)\par
2. Constant and random insertion and removal - LinkedList (ArrayList need to shift the element).\par
3. Interations - Either\par
\b Set:\par
\b0 No duplicate allowed. \par
Can we null in set ?\par
Yes we can have but only one.\par
\b HashSet :\par
\b0 Java implementation uses LinkedList to store hash collision data.\par
\b HashSet efficiency :\par
\b0 add - O(1)\par
remove - O(1)\par
contains - O(1)\par
\b Note: \b0 These notation mainly based on the hash collosion happend in hashset through hashing and not in total size of hash so these notations are O(1). If hash collosion is more then it may become worse than O(1) or similar to O(n) but most of the cases that doesn't happens.\par
Initial capacity of HashSet - 16 Bucket.\par
Hashload factor : number of element / number of baucket.\par
so after load factor 0.75 it rehashes means it increases the size by 16 bucket.\par
load factor = 12/16 = 0.75\par
LinkedHashSet:\par
Its mixed version of LinkedList and HashSet\par
a. Insertion order.\par
b. Order iteration O(1) time.\par
c. Performance\par
\tab add - O(1)\par
\tab contains - O(1)\par
\tab next - O(1)\par
\b TreeSet :\b0\par
Class which is used in treeset should be implemented Comparable.\par
TreeSet performance:\par
add - O(logn)\par
contains - O(logn)\par
interation - O(logn)\par
balancing the tree - O(logn)\par
Since we need to only search for half the either left (smaller element) side or right(greater element) side in the tree so its take O(logn).\par
\b When to use Set\b0\par
1. No duplicate needed.\par
2. Position isn't important.\par
3. Fast lookup.\par
4. Fast contains check.\par
\b HashSet Vs TreeSet\b0\par
HashSet\par
1. Order is not imporatnt.\par
2. Sort is not important.\par
3. Good hashing strategy.\par
4. Predicatble load factor.\par
Use TreeSet for ordered, sorted set.\par
Pros: sorted, based on a red/black tree algorithm, provides O(log(N)) complexity for operations.\par
Cons: value must either be Comparable or you need to provide Comparator in the constructor. Moreover, the HashSet implementation provides better performance as it provides ~O(1) complexity.\par
\b LinkedHashSet:\b0\par
Advantages\par
-LinkedHashSet maintains insertion order of elements. i.e elements are placed as they are inserted.\par
-LinkedHashSet gives the performance of order O(1) for insertion, removal and retrieval operations.\par
-LinkedHashSet allows maximum one null element.\par
-LinkedHashSet uses equals() and hashCode() methods to compare the elements and thus removing the possible duplicate elements.\par
-LinkedHashSet maintains LinkedList along with HashSet to store its elements.\par
-Iterator returned by LinkedHashSet is fail-fast in nature. i.e You will get ConcurrentModificationException if they are modified after the creation of Iterator object.\par
Disadvantages\par
-LinkedHashSet maintains LinkedList along with HashSet to store its elements for which it requires more memory\par
-The performance of LinkedHashSet is between HashSet and TreeSet. Its performance is almost similar to HashSet. But slightly in the slower side as it also maintains LinkedList internally to maintain the insertion order of elements.\par
-LinkedHashSet maintains insertion order of elements whereas HashSet doesn\rquote t maintain any order of elements.\par
\b Map:\par
\b0 Map is key value pair collection. It doesn't implement collection interface.\b\par
HashMap :\par
\b0 HashMap works with hashcode and search for the key based on the hashcode.\par
\b Performace:\b0\par
get - O(1)\par
containsKey - O(1)\par
put - O(1)\par
\b Collections Class:\par
\b0 This is utility class which has different static methods to apply on different collections.\par
\b Why HashTable doesn\rquote t allow null and HashMap does?\b0\par
To successfully store and retrieve objects from a HashTable, the objects used as keys must implement the hashCode method and the equals method. Since null is not an object, it can\rquote t implement these methods. HashMap is an advanced version and improvement on the Hashtable. HashMap was created later.\par

\pard\box\brdrdash\brdrw0 \li720\sa200\sl276\slmult1\cf2\fs20\lang1033\par
\f1\lang9\par

\pard\box\brdrdash\brdrw0 \sa200\sl276\slmult1\cf0\f0\fs22\par
\par
\cf1\f1\fs20\par

\pard\sa200\sl276\slmult1\cf0\f0\fs22\par
\par
\par
}
 